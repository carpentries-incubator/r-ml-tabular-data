---
source: Rmd
title: "Linear and Logistic Regression"
math: true
teaching: 40
exercises: 10
questions:
- "How can a model make predictions?"
- "How do we judge the accuracy of predictions?"
objectives:
- "Define a linear regression model."
- "Define a logistic regression model."
- "Split data into training and testing sets."
keypoints:
- "Regression models can make predictions."
- "Testing sets can be used to measure the accuracy of a model."
---

```{r, include=FALSE}
source("../bin/chunk-options.R")
knitr_fig_path("02-")
```

## Kyphosis Data

Make sure the `rpart` package is loaded, and examine the structure of the `kyphosis` data frame.

```{r}
library(rpart)
str(kyphosis)
```

Notice that there are 81 observations of four variables, so this is a rather small data set for machine learning techniques. In this episode, we will use this data set to illustrate the process of training and testing, where our models will be built using classical linear and logistic regression. 

## Make a training set and a test set

The first step in the process is to create a random train/test split of our data set. There are various R packages that automate such tasks, but it is illustrative to use base R for now.

The following commands will randomly select the row indexes of the training set (and therefore also of the testing set).

```{r}
trainSize <- round(0.75 * nrow(kyphosis))
set.seed(6789) # so we all get the same random sets
trainIndex <- sample(nrow(kyphosis), trainSize)
```

Take a look at the `trainIndex` variable in the Environment tab of RStudio. Since we set a particular value for the random seed, we should all see the same sample of random numbers.

Next we form two data frames using these indexes. Recall that the selection of `-trainIndex` will select all rows whose indexes are *not* in the `trainIndex` vector.

```{r}
trainDF <- kyphosis[trainIndex, ]
testDF <- kyphosis[-trainIndex, ]
```

We can `View` the train and test sets in RStudio to check that they form a random partition of the `kyphosis` data.

```{r, eval=FALSE}
View(trainDF)
View(testDF)
```

## Linear Regression as Supervised Learning

In the previous episode, we constructed a scatterplot of `Number` versus `Start` and observed a slight negative assocition. We can model this association with a linear function 

$$ 
\text{Start} = a + b \cdot \text{Number}
$$
where $a$ and $b$ are the intercept and slope, respectively, of the least squares regression line. To compute $a$ and $b$, we use the `lm` function in R.

```{r}
model1 <- lm(Start ~ Number, data = trainDF)
summary(model1)
```

The predicted `Start` is obtained by multiplying `Number` by `r round(model1$coefficients[2], 4)` and adding `r round(model1$coefficients[1], 4)`.

> ## Challenge: Make a prediction
>
> Predict the number of the topmost vertebra when the number of
> vertebrae involved is 3.
>
> > ## Solution
> > 
> > Three times `r round(model1$coefficients[2], 4)` plus 
> > `r round(model1$coefficients[1], 4)` 
> > is approximately 
> > `r round(3 * model1$coefficients[2] + model1$coefficients[1], 2)`.
> > 
> {: .solution}
{: .challenge}

## Try the Testing Data Set

In R there is a generic method called `predict` that will make predictions given models of various types. For example, we can compute the predicted starting vertebrae for all the cases in our testing set as follows.

```{r}
predictedStart <- predict(model1, testDF)
```

> ## Challenge: Check our prediction
>
> Check that the result of the `predict` function agrees with the 
> result of the previous challenge.
>
> > ## Solution
> > 
> > ```{r}
> > head(predictedStart)
> > head(testDF)
> > ```
> > 
> > Notice that the first row of our testing set has a `Number` value of 3,
> > and the first value of `predictedStart` agrees with our answer to the
> > previous challenge.
> > 
> {: .solution}
{: .challenge}

Notice that, in general, the value of `Start` predicted by the model will not equal the actual value of `Start` in the testing set. However, in an accurate model, we would hope that the predicted values will be close to the actual values. To assess how close our predictions are to reality, we compute a vector of errors: predicted values minus actual values.

```{r}
actualStart <- testDF$Start
errors <- predictedStart - actualStart
cat(round(errors, 1))
```

## Measuring the Prediction Error

There are several ways to summarize the overall error in a regression model. The average error is not a good choice, because errors will usually have positive and negative values, which cancel. To avoid this cancellation effect, we can take the mean of the squares of the errors: the *Mean Squared Error*, or MSE.

```{r}
mean(errors^2)
```

An alternative that has the same units as the output is the square root of the MSE: the *Root Mean Squared Error*, or RMSE.

```{r}
sqrt(mean(errors^2))
```

> ## Challenge: Mean Absolute Error
>
> The *Mean Absolute Error* (MAE) is the average of the absolute values of the
> errors.  Compute the MAE for the above example.
>
> > ## Solution
> > 
> > ```{r}
> > mean(abs(errors))
> > ```
> > 
> {: .solution}
{: .challenge}

We will compare most of the regression models that follow using the RMSE of the prediction error on the testing set.

## Logistic Regression

TODO: Density plots

TODO: Logistic model

```{r}
model2 <- glm(Kyphosis ~ Age + Number + Start, data = trainDF, family = "binomial")
```

Shorthand notation:

```{r}
model2 <- glm(Kyphosis ~ ., data = trainDF, family = "binomial")
```

```{r}
predict(model2, testDF, type = "response")
```

```{r}
levels(kyphosis$Kyphosis)
```

```{r}
predictedKyphosis <- ifelse(predict(model2, testDF, type = "response") < 0.5,
                            "absent", "present")
predictedKyphosis
```

TODO: accuracy measurement

```{r}
testDF$Kyphosis == predictedKyphosis
```

```{r}
accuracy <- sum(testDF$Kyphosis == predictedKyphosis)/nrow(testDF)
cat("Proportion of correct predictions using testing data: ", accuracy, "\n")
```

TODO: Challenge: Try a different random seed. Does the accuracy stay the same?

TODO: Challenge: Try using multinom from nnet package.
